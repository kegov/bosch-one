/**
  * @file bhix60.h
  * @brief BHIx60 driver extended public API
  * @details 
  * 
  * The bhix60 driver is a thin wrapper on the BHY2 Sensor API, and provides a Zephyr-compatible 
  * interface to BHIx60 devices. 
  * 
  * It is possible to access the BHIx60 driver exclusively via the Zephyr Sensor API.
  * The following additional API functions provide more fine-grained control for special situations.
  * 
  * @copyright Copyright (c) 2023 Bosch Sensortec GmbH
  * 
  * SPDX-License-Identifier: Apache-2.0
  */
#include <zephyr/kernel.h>
#include <zephyr/drivers/sensor.h>
#include <bhy2.h>
#include <bhy2_parse.h>

#ifndef _BHIX60_H_
#define _BHIX60_H_
#ifdef __cplusplus
extern "C" {
#endif
enum sensor_channel_bhix60; /*forward declaration. Actual declaration is at the end of the file*/
/**
  * @brief template for application-defined firmware accessor
  * @details
  * In case BHIx60 is configured for run-time firmware loading to the RAM or FLASH of BHIx60
  * (CONFIG_BHIX60_UPLOAD_FW_TO_FLASH or CONFIG_BHIX60_UPLOAD_FW_TO_RAM), the application needs
  * to define the following accessor function to provide the BHIx60 driver access to the 
  * application-defined firmware. 
  * 
  * Example: The BHIx60 firmwares generated by the BHY2 firmware SDK are typically available as 
  * C header files with names such as "BHI260AP.fw.h", containing an array definition like this:
  * 
  * @code{.c}
  *     const unsigned char bhy2_firmware_image[] = {...};
  * @endcode
  * 
  * The application should define the accessor function as follows:
  * @code{.c}
  *     #include <bhi260.h>
  *     #include "BHI260AP.fw.h" //change to the name of the actual firmware file
  *     int bhix60_get_firmware(const struct device *dev, unsigned char **fw,unsigned int *fw_sz)
  *     {
  *         (void)dev;
  *         *fw = bhy2_firmware_image;
  *         *fw_sz = sizeof(bhy2_firmware_image);
  *         return 0;
  *     }
  * @endcode
  * 
  * NOTE1: In case a firmware is not (yet) available, an error code (-1) can be returned instead of 0
  * in a place-holder function to avoid build and runtime errors
  * 
  * NOTE2: In case the application supports multiple BHIx60 devices, the dev argument passed by the driver
  * can be used to load different firmwares in different devices, if required.
  * 
  * @param[in] BHIx60 device instance pointer
  * @param[out] fw to be filled with a pointer to the byte array of the firmware
  * @param[out] fw_sz to be filled with the size of the byte array of the firmware
  * @return 0 no errors
  *        -1 firmware not available
  */
int bhix60_get_firmware(const struct device *dev, unsigned char **fw,unsigned int *fw_sz);

/**
 * @brief Register a virtual sensor prior to usage
 * 
 * This function sets up the internal buffer, locks and callbacks for polling a virtual
 * sensor. This function is automatically called when calling sensor_attr_set() with the 
 * attribute SENSOR_ATTR_CONFIGURATION. This function can be called directly if using the
 * BHIx60 raw API exclusively.
 * @param dev BHIx60 device
 * @param chan BHIx60 virtual sensor channel
 * @return 0 on success, other errno values on failure
 */
int bhix60_register_virtual_sensor(const struct device *dev, enum sensor_channel chan);

/**
 * @brief Configure a virtual sensor
 * Configure the sampling rate and FIFO latency of a virtual sensor.
 * 
 * A virtual sensor can be configured only after it has been registered, 
 * otherwise this call will fail.
 * 
 * This function is automatically called when calling sensor_attr_set() with the 
 * attribute SENSOR_ATTR_CONFIGURATION. In that case, val->val1 should contain the 
 * sampling rate in hz and val->val2 the latency in ms. This function can be called 
 * directly if using the BHIx60 raw API exclusively.
 * 
 * Sampling rate is the rate in hz at which the virtual sensor data is read by BHIx60.
 * Sampling rate is used also to enable/disable the virtual sensor. Set it to 0 for disable, a
 * positive value for enable.
 * 
 * The corresponding way of enabling/disabling a virtual sensor via the standard sensor API
 * is to call sensor_attr_set() with the attribute SENSOR_ATTR_SAMPLING_FREQUENCY
 * Set val->val1 to 0 to disable a virtual sensor, and to a positve value to set it to
 * the sampling rate in Hz. The major difference with respect to using the attribute 
 * SENSOR_ATTR_CONFIGURATION is that in this case, an attempt is not made to register the
 * virtual sensor, and latency is not changed.
 * 
 * Latency indicates how much time in ms a new value is retained in the BHIx60 FIFO before a 
 * notification to the host CPU is sent via interrupt pin. The default value is 0 (notify
 * CPU immediately). A higher value can be set prior to going to sleep state. 
 * 
 * @param dev BHIx60 device
 * @param chan BHIx60 virtual sensor channel
 * @param sample_rate Rate in hz at which sensor data is read by BHIx60. 
 * @param report_latency_ms Time in ms a new value is retained in BHIx60 FIFO
 * @return 0 on success, other errno values on failure
 */
int bhix60_config_virtual_sensor(const struct device *dev, enum sensor_channel chan, 
              	float sample_rate, uint32_t report_latency_ms);

/**
 * @brief typedef of raw data parser required by bhix60_channel_parse_get()
 */
typedef void (* bhix60_parser_t)(void *raw_data,void *parsed_data);

/**
 * @brief Get parsed data from a BHIx60 virtual sensor
 * This function can be used to retrieve the raw data from a virtual sensor as specified
 * in the BHIx60 product data sheet (refer section "FIFO Data Types and Formats") and parse
 * it to a suitable data structure.
 *
 * This function is a low-level alternative to accessing BHIx60 vitual sensor data via 
 * sensor_channel_get(). It is especially useful in case of custom virtual sensors or 
 * complex sensors which are not supported in sensor_channel_get(). However, it can be 
 * used as a general replacement to sensor_channel_get() even otherwise, as it is marginally 
 * more efficient, and provides access to the timestamp, which is not supported in the 
 * standard Zephyr sensor API  
 * 
 * It requires a parser function to be passed as a parameter, which will be applied on the
 * raw data from FIFO. There are various parsers pre-defined in bhy2_parse.h in the 
 * BHY2 sensor API. The below helper macros combine bhix60_channel_raw_get() with a 
 * standard parser.
 * 
 * In case of custom virtual sensor or unsupported virtual sensors, it is up to application
 * to provide a custom parser on the same lines as the standard parsers. Even if no parsing is 
 * required, i.e. direct access to the raw data is desired, it is necessary to supply a copy
 * parser that will use memcpy to copy the FIFO raw data to an application buffer of 
 * sufficient size. 
 * @param dev BHIx60 device
 * @param chan BHIx60 virtual sensor channel
 * @param parse_func parser function applied to raw data
 * @param parsed_data application data structure to be filled by the parser function
 * @param timestamp timestamp of data, in ns since start of application
 * @return 0: success
 *          -errno in case of failure
 */
int bhix60_channel_parse_get(const struct device *dev,
			    enum sensor_channel chan,
			    bhix60_parser_t parse_func,
                void *parsed_data,
				uint64_t *timestamp);

/**
 * @brief Convert BHIx60 time stamp to seconds and nanoseconds since application start
 * 
 * @param timestamp timestamp returned by  bhix60_channel_raw_get() and helper macros
 * @param s seconds component of timestamp
 * @param ns nanoseconds component of timestamp
 */
void bhix60_convert_time(uint64_t timestamp, uint32_t *s, uint32_t *ns);

/**
 * @brief Helper macros that combine bhix60_channel_parse_get() with a BHY2 parser
 * The BHY2 sensor data types are defined in bhy2_defs.h 
 */

static inline int bhix60_get_orientation(const struct device *dev,
			      enum sensor_channel chan,
			      struct bhy2_data_orientation *orientation_data,
				    uint64_t *timestamp){
    return bhix60_channel_parse_get(dev,chan,(bhix60_parser_t)bhy2_parse_orientation,orientation_data,timestamp);
}

static inline int bhix60_get_temperature_celsius(const struct device *dev,
			      enum sensor_channel chan,
			      float *temperature,
				    uint64_t *timestamp){
    return bhix60_channel_parse_get(dev,chan,(bhix60_parser_t)bhy2_parse_temperature_celsius,temperature,timestamp);
}

static inline int bhix60_get_humidity(const struct device *dev,
			      enum sensor_channel chan,
			      float *humidity,
				    uint64_t *timestamp){
    return bhix60_channel_parse_get(dev,chan,(bhix60_parser_t)bhy2_parse_humidity,humidity,timestamp);
}

static inline int bhix60_get_pressure(const struct device *dev,
			      enum sensor_channel chan,
			      float *pressure,
				    uint64_t *timestamp){
    return bhix60_channel_parse_get(dev,chan,(bhix60_parser_t)bhy2_parse_pressure,pressure,timestamp);
}

static inline int bhix60_get_altitude(const struct device *dev,
			      enum sensor_channel chan,
			      float *altitude,
				    uint64_t *timestamp){
    return bhix60_channel_parse_get(dev,chan,(bhix60_parser_t)bhy2_parse_altitude,altitude,timestamp);
}

static inline int bhix60_get_quaternion(const struct device *dev,
			      enum sensor_channel chan,
			      struct bhy2_data_quaternion *quaternion,
				    uint64_t *timestamp){
    return bhix60_channel_parse_get(dev,chan,(bhix60_parser_t)bhy2_parse_quaternion,quaternion,timestamp);
}

static inline int bhix60_get_3d_vector(const struct device *dev,
			      enum sensor_channel chan,
			      struct bhy2_data_xyz *vector,
				    uint64_t *timestamp){
    return bhix60_channel_parse_get(dev,chan,(bhix60_parser_t)bhy2_parse_xyz,vector,timestamp);
}

static inline void bhy2_parse_32u(uint8_t *raw_data,uint32_t *data){    
    *data = BHY2_LE2U32(raw_data); 
}

static inline int bhix60_get_32u(const struct device *dev,
			      enum sensor_channel chan,
			      uint32_t *data,
				  uint64_t *timestamp){
    return bhix60_channel_parse_get(dev,chan,(bhix60_parser_t)bhy2_parse_32u,data,timestamp);
}

static inline void bhy2_parse_24u(uint8_t *raw_data,uint32_t *data){    
    *data = BHY2_LE2U24(raw_data); 
}
static inline int bhix60_get_24u(const struct device *dev,
			      enum sensor_channel chan,
			      uint32_t *data,
				    uint64_t *timestamp){
    return bhix60_channel_parse_get(dev,chan,(bhix60_parser_t)bhy2_parse_24u,data,timestamp);
}

static inline void bhy2_parse_16u(uint8_t *raw_data,uint32_t *data){    
    *data = BHY2_LE2U16(raw_data); 
}
static inline int bhix60_get_16u(const struct device *dev,
			      enum sensor_channel chan,
			      uint16_t *data,
				    uint64_t *timestamp){
    return bhix60_channel_parse_get(dev,chan,(bhix60_parser_t)bhy2_parse_16u,data,timestamp);
}

/**
 * @brief Convert Zephyr Sensor Channel to corresponding BHY2 Sensor ID
 * @param chan Zephyr Sensor Channel
 * @return >0 BHY2 Sensor ID
 *  -ENOTSUP  Sensor Channel has no corresponding BHY2 Sensor IF
 */
int16_t  bhix60_chan_to_sid(enum sensor_channel chan);

/**
 * @brief Convert BHY2 Sensor ID to Zephyr Sensor Channel  
 * @param sid BHY2 Sensor ID
 * @return Zephyr Sensor Channel 
 */
static inline enum sensor_channel  bhix60_sid_to_chan(int16_t sid){
    return (enum sensor_channel)( SENSOR_CHAN_PRIV_START + sid);
}

/**
 * @brief get BHY2 device from Zephyr BHIX60 device 
 * convert the BHIx60 Zephyr device pointer to a BHY2 dev pointer for 
 * making raw calls to the BHY2 Sensor API
 * 
 * @param dev Zephyr device pointer of a BHIX60 device
 * @return struct bhy2_dev* corresponding BHY2 device pointer
 */
struct bhy2_dev *bhix60_get_bhy2_dev(const struct device *dev);

/**
 * @brief Zephyr-compatible wrappers for miscellaneous useful BHY2 commands
 * Other advanced API functions can be directly accessed if required using 
 * bhix60_sid_to_chan() and bhix60_get_bhy2_dev()
 */
/* signal to BHIx60 that host CPU is entering standby mode, and non-wakeup FIFO interrupts
should be suspended. Or that it is resuming, and non-wakeup interrupts can resume
status: entering suspend/exiting suspend
*/
int bhix60_host_standby(const struct device *dev, bool status);
/*reset BHIx60 device*/
int bhix60_soft_reset(const struct device *dev);
/*flush all FIFOs, discarding data*/
int bhix60_flush_fifo(const struct device *dev);

/**
 * @brief Custom BHIx60 extention to Zephyr Sensor Triggers
 * For Event-type BHIx60 Virtual Sensors (i.e., virtual sensors that signal an event, 
 * such as Significant Motion or Tilt Detected, and do not have associated
 * data), trigger type SENSOR_TRIG_BHIX60_EVENT can be used in sensor_trigger_set()
 * to register a callback function. The actual event that causes the callback depends 
 * on the virtual sensor channel for which the callback is registered.
 */
enum sensor_trigger_type_bhix60{
    SENSOR_TRIG_BHIX60_EVENT = SENSOR_TRIG_PRIV_START+1,
    /**
   * The below triggers are proposed to be added to Zephyr Sensor.H as standard triggers.
   * For the time being, they are declared here as extended triggers. In BHIx60.C, they
   * are all mapped to SENSOR_TRIG_BHIX60_EVENT.    
   * TODO: Move below triggers to Sensor.H when proposal to add them is accepted
   */
    SENSOR_TRIG_SIG_MOTION,
    SENSOR_TRIG_STEP,
    SENSOR_TRIG_TILT,
    SENSOR_TRIG_WAKE_GEST,
    SENSOR_TRIG_GLANCE_GEST,
    SENSOR_TRIG_PICKUP_GEST,
    SENSOR_TRIG_WRIST_TILT_GEST,
};

/**
 * @brief Custom BHIx60 extention to Zephyr Sensor Channels
 * 
 * BHY2 Virtual Sensor IDs are extended with the custom channel baseline of Zephyr Sensor API 
 * to obtain BHIx60 specific virtual channels. This scheme permits easy conversion between
 * BHY2 IDs and Zephyr IDs 
 */
enum sensor_channel_bhix60 {
  SENSOR_CHAN_BHIX60_START          = SENSOR_CHAN_PRIV_START,                               /*Start of BHIX60 virtual sensor range*/
  SENSOR_CHAN_BHIX60_ACC_PASS	    = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_ACC_PASS	,	/* Accelerometer passthrough */
  SENSOR_CHAN_BHIX60_ACC_RAW	    = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_ACC_RAW	,	/* Accelerometer uncalibrated */
  SENSOR_CHAN_BHIX60_ACC	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_ACC	    ,	/* Accelerometer corrected */
  SENSOR_CHAN_BHIX60_ACC_BIAS	    = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_ACC_BIAS	,	/* Accelerometer offset */
  SENSOR_CHAN_BHIX60_ACC_WU	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_ACC_WU	,	/* Accelerometer corrected wake up */
  SENSOR_CHAN_BHIX60_ACC_RAW_WU	    = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_ACC_RAW_WU,  /* Accelerometer uncalibrated wake up */
  SENSOR_CHAN_BHIX60_SI_ACCEL	    = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_SI_ACCEL	,	/* Virtual Sensor ID for Accelerometer */
  SENSOR_CHAN_BHIX60_GYRO_PASS	    = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_GYRO_PASS,   /* Gyroscope passthrough */
  SENSOR_CHAN_BHIX60_GYRO_RAW	    = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_GYRO_RAW	,	/* Gyroscope uncalibrated */
  SENSOR_CHAN_BHIX60_GYRO	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_GYRO	,	    /* Gyroscope corrected */
  SENSOR_CHAN_BHIX60_GYRO_BIAS	    = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_GYRO_BIAS,	/* Gyroscope offset */
  SENSOR_CHAN_BHIX60_GYRO_WU	    = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_GYRO_WU,	    /* Gyroscope wake up */
  SENSOR_CHAN_BHIX60_GYRO_RAW_WU    = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_GYRO_RAW_WU,	/* Gyroscope uncalibrated wake up */
  SENSOR_CHAN_BHIX60_SI_GYROS	    = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_SI_GYROS	,	/* Virtual Sensor ID for Gyroscope */
  SENSOR_CHAN_BHIX60_MAG_PASS	    = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_MAG_PASS	,	/* Magnetometer passthrough */
  SENSOR_CHAN_BHIX60_MAG_RAW	    = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_MAG_RAW	,	/* Magnetometer uncalibrated */
  SENSOR_CHAN_BHIX60_MAG	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_MAG  ,	    /* Magnetometer corrected */
  SENSOR_CHAN_BHIX60_MAG_BIAS	    = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_MAG_BIAS,	/* Magnetometer offset */
  SENSOR_CHAN_BHIX60_MAG_WU	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_MAG_WU   ,	/* Magnetometer wake up */
  SENSOR_CHAN_BHIX60_MAG_RAW_WU	    = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_MAG_RAW_WU,	/* Magnetometer uncalibrated wake up */
  SENSOR_CHAN_BHIX60_GRA	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_GRA	    ,	/* Gravity vector */
  SENSOR_CHAN_BHIX60_GRA_WU	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_GRA_WU	,	/* Gravity vector wake up */
  SENSOR_CHAN_BHIX60_LACC	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_LACC 	,	/* Linear acceleration */
  SENSOR_CHAN_BHIX60_LACC_WU	    = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_LACC_WU	,	/* Linear acceleration wake up */
  SENSOR_CHAN_BHIX60_RV	            = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_RV	    ,	/* Rotation vector */
  SENSOR_CHAN_BHIX60_RV_WU	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_RV_WU	,	/* Rotation vector wake up */
  SENSOR_CHAN_BHIX60_GAMERV	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_GAMERV	,	/* Game rotation vector */
  SENSOR_CHAN_BHIX60_GAMERV_WU	    = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_GAMERV_WU,	/* Game rotation vector wake up */
  SENSOR_CHAN_BHIX60_GEORV	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_GEORV	,	/* Geo-magnetic rotation vector */
  SENSOR_CHAN_BHIX60_GEORV_WU	    = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_GEORV_WU	,	/* Geo-magnetic rotation vector wake up */
  SENSOR_CHAN_BHIX60_ORI	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_ORI	    ,	/* Orientation */
  SENSOR_CHAN_BHIX60_ORI_WU	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_ORI_WU	,	/* Orientation wake up */
  SENSOR_CHAN_BHIX60_TILT	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_TILT_DETECTOR,/* Tilt detector */
  SENSOR_CHAN_BHIX60_STD	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_STD	,	    /* Step detector */
  SENSOR_CHAN_BHIX60_STC	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_STC	,	    /* Step counter */
  SENSOR_CHAN_BHIX60_STC_WU	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_STC_WU	,	/* Step counter wake up */
  SENSOR_CHAN_BHIX60_SIG	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_SIG	,	    /* Significant motion */
  SENSOR_CHAN_BHIX60_WAKE_GESTURE	= SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_WAKE_GESTURE,    /* Wake gesture */
  SENSOR_CHAN_BHIX60_GLANCE_GESTURE	= SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_GLANCE_GESTURE,  /* Glance gesture */
  SENSOR_CHAN_BHIX60_PICKUP_GESTURE	= SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_PICKUP_GESTURE,  /* Pickup gesture */
  SENSOR_CHAN_BHIX60_AR	            = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_AR	,	    /* Activity recognition */
  SENSOR_CHAN_BHIX60_WRIST_TILT_GESTURE	= SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_WRIST_TILT_GESTURE,  /* Wrist tilt gesture */
  SENSOR_CHAN_BHIX60_DEVICE_ORI	    = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_DEVICE_ORI,      /* Device orientation */
  SENSOR_CHAN_BHIX60_DEVICE_ORI_WU	= SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_DEVICE_ORI_WU,   /* Device orientation wake up */
  SENSOR_CHAN_BHIX60_STATIONARY_DET	= SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_STATIONARY_DET,  /* Stationary detect */
  SENSOR_CHAN_BHIX60_MOTION_DET	    = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_MOTION_DET,	    /* Motion detect */
  SENSOR_CHAN_BHIX60_ACC_BIAS_WU	= SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_ACC_BIAS_WU,	    /* Accelerometer offset wake up */
  SENSOR_CHAN_BHIX60_GYRO_BIAS_WU	= SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_GYRO_BIAS_WU,    /* Gyroscope offset wake up */
  SENSOR_CHAN_BHIX60_MAG_BIAS_WU	= SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_MAG_BIAS_WU,	    /* Magnetometer offset wake up */
  SENSOR_CHAN_BHIX60_STD_WU	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_STD_WU,	    /* Step detector wake up */
  SENSOR_CHAN_BHIX60_TEMP	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_TEMP	,	    /* Temperature */
  SENSOR_CHAN_BHIX60_BARO	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_BARO	,	    /* Barometer */
  SENSOR_CHAN_BHIX60_HUM	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_HUM	,	    /* Humidity */
  SENSOR_CHAN_BHIX60_GAS	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_GAS	,	    /* Gas */
  SENSOR_CHAN_BHIX60_TEMP_WU	    = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_TEMP_WU	,	/* Temperature wake up */
  SENSOR_CHAN_BHIX60_BARO_WU	    = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_BARO_WU	,	/* Barometer wake up */
  SENSOR_CHAN_BHIX60_HUM_WU	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_HUM_WU	,	/* Humidity wake up */
  SENSOR_CHAN_BHIX60_GAS_WU	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_GAS_WU	,	/* Gas wake up */
  SENSOR_CHAN_BHIX60_STC_LP	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_STC_LP	,	/* Step counter Low Power*/
  SENSOR_CHAN_BHIX60_STD_LP	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_STD_LP	,	/* Step detector Low Power*/
  SENSOR_CHAN_BHIX60_SIG_LP	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_SIG_LP	,	/* Significant motion Low Power*/
  SENSOR_CHAN_BHIX60_STC_LP_WU	    = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_STC_LP_WU,	/* Step counter Low Power wake up */
  SENSOR_CHAN_BHIX60_STD_LP_WU	    = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_STD_LP_WU,	/* Step detector Low Power wake up */
  SENSOR_CHAN_BHIX60_SIG_LP_WU	    = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_SIG_LP_WU,	/* Significant motion Low Power wake up */
  SENSOR_CHAN_BHIX60_ANY_MOTION_LP  = SENSOR_CHAN_PRIV_START +  BHY2_SENSOR_ID_ANY_MOTION_LP,	   /* Any motion Low Power */
  SENSOR_CHAN_BHIX60_ANY_MOTION_LP_WU= SENSOR_CHAN_PRIV_START+ BHY2_SENSOR_ID_ANY_MOTION_LP_WU,    /* Any motion Low Powerwake up */
  SENSOR_CHAN_BHIX60_EXCAMERA	    = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_EXCAMERA	,	/* External camera trigger */
  SENSOR_CHAN_BHIX60_GPS	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_GPS	,	    /* GPS */
  SENSOR_CHAN_BHIX60_LIGHT	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_LIGHT	,	/* Light */
  SENSOR_CHAN_BHIX60_PROX	        = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_PROX	,	    /* Proximity */
  SENSOR_CHAN_BHIX60_LIGHT_WU	    = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_LIGHT_WU	,	/* Light wake up */
  SENSOR_CHAN_BHIX60_PROX_WU	    = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_PROX_WU	,	/* Proximity wake up */
  SENSOR_CHAN_BHIX60_END            = SENSOR_CHAN_PRIV_START +	BHY2_SENSOR_ID_MAX,         /*End of BHY2 virtual sensor range*/

  /**
   * The below channels are proposed to be added to Zephyr Sensor.H as standard channels.
   * For the time being, they are declared here as extended channels. In BHIx60.C, they
   * are mapped to BHY2 virtual sensor IDs, just like the existing standard Zephyr channels.    
   * TODO: Move below channels to Sensor.H when proposal to add them is accepted
   */
  SENSOR_CHAN_ROTATION_QTR,
  SENSOR_CHAN_GAME_ROTATION_QTR,
  SENSOR_CHAN_GEOMAG_ROTATION_QTR,
  SENSOR_CHAN_ORIENTATION_HPR,
  SENSOR_CHAN_GRAVITY_XYZ,
  SENSOR_CHAN_LINEAR_ACCEL_XYZ,
  SENSOR_CHAN_STEP_CNT,
  SENSOR_CHAN_DEVICE_ORIENTATION,
  SENSOR_CHAN_CAMERA_SHUTTER,
  /*Event type channels*/
  SENSOR_CHAN_SIG_MOTION,
  SENSOR_CHAN_STEP,
  SENSOR_CHAN_TILT,
  SENSOR_CHAN_WAKE_GEST,
  SENSOR_CHAN_GLANCE_GEST,
  SENSOR_CHAN_PICKUP_GEST,
  SENSOR_CHAN_WRIST_TILT_GEST,
  SENSOR_CHAN_STATIONARY,
  SENSOR_CHAN_MOTION,
};

#ifdef __cplusplus
}
#endif

#endif //_BHIX60_H_
